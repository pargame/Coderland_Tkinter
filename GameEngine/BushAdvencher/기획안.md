
# BushAdvencher 게임 엔진 기획안

최종 목표: Pygame 기반의 타일 맵 에디터와 런타임(플레이) 환경을 하나의 엔진으로 제공한다. 에디터에서 아이템(타일/엔티티)을 좌측의 아이템 패널에서 뷰 패널로 드래그앤드롭(이하 DnD)하여 배치할 수 있고, 뷰 패널 상단의 `플레이` 버튼을 누르면 미리 지정한 플레이어 시작 지점에서 플레이어가 스폰되어 실제 플레이가 가능해야 한다.

## 1. 핵심 컨셉과 우선순위
- 타일 기반(Tiled 스타일) 맵: 정사각형 그리드, 타일 스냅, 여러 레이어(배경, 오브젝트, 충돌 레이어).
- WYSIWYG 에디터: 에디팅 모드에서 배치와 시각적 피드백이 즉시 반영.
- 드래그앤드롭 배치: 아이템 패널 -> 뷰 패널 (마우스 드래그)로 직관적 배치.
- 플레이 모드 토글: 에디터와 동일 프로그램 내에서 `플레이` 버튼으로 즉시 테스트.
- 간단한 데이터 직렬화: JSON(또는 YAML)로 맵 저장/불러오기.

우선순위(MVP):
1) 타일 그리드 렌더링 및 타일 팔레트(아이템 패널) 구현
2) DnD로 타일/아이템 배치, 스냅 기능
3) 플레이어 시작 지점(Spawn Point) 설정 툴
4) 뷰 상단의 `플레이` 버튼으로 플레이 모드 전환 및 플레이어 스폰/이동(기본 WASD/화살표)
5) 맵 저장/불러오기(JSON)

## 2. UI 구성 (에디터 화면)
- 좌측: 아이템 패널(Item Panel)
	- 타일/엔티티 목록(썸네일), 카테고리/탭
	- 드래그 시작 지점
- 중앙: 뷰 패널(View Panel)
	- 타일 그리드(오버레이), 줌/패닝(마우스휠+우클릭 드래그 또는 스페이스+드래그)
	- 마우스 포인터에 스냅된 배치 프리뷰
	- 선택/지우개 툴, 레이어 선택 드롭다운
	- 플레이 버튼(상단 툴바) 및 모드 표시(에디트 / 플레이)
- 우측(선택 사항): 속성 패널(Properties)
	- 선택한 아이템의 속성(충돌 여부, 이벤트 스크립트 키 등)

모바일/터치 미지원(초기 단계)

## 3. 에디터 동작 흐름
1. 아이템 패널에서 타일을 클릭하거나 드래그하여 뷰로 이동.
2. 뷰에 진입한 마우스는 그리드에 스냅되어 배치 프리뷰를 표시.
3. 마우스 버튼을 놓으면 해당 타일이 선택된 레이어에 배치.
4. 플레이어 시작 지점을 설정하려면 전용 툴(아이콘)을 선택하고 맵에 클릭.
5. 저장: 현재 맵 데이터를 JSON으로 직렬화하여 파일 저장.

단축키 제안:
- S: 저장, O: 불러오기, Z: 실행 취소, Y: 다시 실행
- P: 플레이 모드 토글

## 4. 플레이 모드 동작
- 플레이 버튼을 누르면 현재 에디트 상태(저장중 또는 메모리상)를 기준으로 플레이 모드로 전환.
- 엔진은 플레이어 엔티티를 미리 지정한 시작 지점(Spawn Point)에서 스폰.
- 입력: 키보드(좌/우/상/하 또는 WASD)로 이동. 충돌 체크(충돌 레이어에 따라 이동 제약).
- 카메라: 플레이어 중심으로 따라오기(맵 경계 클램핑).
- 플레이 종료: ESC 또는 툴바의 `정지(Stop)` 버튼으로 에디트 모드로 복귀(복귀 시 에디트 상태 유지).

디버깅 표시(플레이 모드): FPS, 플레이어 좌표, 충돌 박스 표시 토글

## 5. 데이터/파일 포맷 (제안)
- 맵 파일: JSON
	- meta: {name, tilesetRefs, tileSize, width, height, layers: [...]}
	- layers: [{name, type: "tile"|"object"|"collision", data: 2D array or sparse list}, ...]
	- entities: [{id, type, x, y, props}, ...] (player spawn included)

예시 스켈레톤:

{
	"meta": {"name": "level1", "tileSize": 32, "width": 100, "height": 50},
	"layers": [ {"name":"background","type":"tile","data": [...]}, {"name":"collision","type":"collision","data": [...] } ],
	"entities": [ {"id":"player_spawn","type":"spawn","x":64,"y":96} ]
}

타일셋: PNG 아틀라스 + 메타(타일 인덱스 맵).

## 6. 아키텍쳐 제안
- modules/
	- engine/ : 런타임 엔진(렌더러, 물리, 입력, 엔티티 시스템)
	- editor/ : 에디터 UI, DnD, 레이어/툴 관리
	- data/ : 맵 직렬화/역직렬화, 타일셋 로더
	- ui/ : 공용 툴바/패널 위젯(버튼, 리스트)
	- resources/ : 타일셋, 아이템 이미지, 샘플 맵

컴포넌트 간 계약(작은 'contract'):
- Map JSON -> 입력: 파일 경로, 출력: Map 객체(타일 배열, 엔티티 리스트). 에러: 포맷 불일치 -> 예외 반환.
- Editor.place_item(item, x, y, layer) -> 결과: true/false(충돌시 false).
- Engine.spawn_player(x,y) -> 결과: Player 인스턴스 또는 에러.

## 7. 엣지 케이스 및 고려사항
- 맵이 매우 큰 경우(수천 x 수천) 메모리/렌더 비용: 뷰포트 기반 렌더링과 레이어 압축/스파스 저장 필요.
- 드래그 앤 드롭 중 빠른 마우스 이동 시 프리뷰 누락: 입력 샘플링과 스냅 보정 적용.
- 동일 위치 다중 아이템 배치/레이어 충돌: 레이어 우선순위와 충돌 플래그로 해결.
- 플레이 도중 에디터 리소스가 변경될 경우: 플레이는 에디터의 스냅샷(복사본)을 사용.

## 8. 테스트 전략
- 유닛 테스트
	- 맵 저장/불러오기 (동일성)
	- 엔티티 스폰/좌표 계산
	- 레이어 충돌 판정
- 통합/수동 테스트
	- 에디터에서 아이템 DnD로 배치 후 플레이 테스트(수동)
	- 대용량 맵 스크롤/렌더 성능 확인

## 9. 구현 계획(단계별 작업 항목)
MVP (1-2주 추정, 단독 개발자 기준):
1. Pygame 윈도우 기초 셋업, 메인 루프, 입력 이벤트 분기
2. 그리드 렌더러와 기본 타일 팔레트(아이템 패널) 렌더링
3. 마우스 스냅/배치 로직 + 간단한 저장/불러오기
4. 플레이 버튼으로 플레이 모드 전환 및 플레이어 이동(충돌 단순화)

이후(고도화, 2-6주):
- 레이어/속성 패널, Undo/Redo, 타일 애니메이션, 타일맵 최적화, 스크립트 트리거 이벤트, 에셋 관리

작업 분해(첫 커밋 후보 파일):
- `engine/renderer.py`, `engine/player.py`, `editor/editor.py`, `editor/ui.py`, `data/map_io.py`, `resources/sample_tileset.png`, `examples/simple_editor.py`

## 10. 산출물 및 검증 기준
- 산출물
	- 실행 가능한 에디터/플레이어 예제(`simple_editor.py`)
	- 샘플 맵 1개
	- 문서: 이 기획안(`기획안.md`)과 사용법 README
- 검증 기준
	- 에디터에서 DnD로 타일/스폰 지점을 배치할 수 있다. (핵심)
	- `플레이` 버튼을 누르면 플레이어가 스폰되고, 기본 이동이 동작한다. (핵심)
	- 맵을 저장/불러오기하면 동일한 맵이 재현된다.

## 11. 다음 단계(제가 도와드릴 수 있는 것)
1. 바로 구현할 것인지, 에디터 UI를 Pygame 내부에서 만들지 아니면 Tkinter/Qt로 만들지 결정(권장: Pygame 내부로 통합).
2. MVP 구현을 위한 최소 파일/코드 스캐폴딩 생성(제가 생성해 드리겠습니다).
3. 우선순위에 따라 기능을 하나씩 구현하고, 각 단계마다 자동화된 간단 테스트 추가.